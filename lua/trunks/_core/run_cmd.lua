---@class trunks.RunCmdOpts
---@field stdin? string[]
---@field rerender? boolean
---@field error_codes_to_ignore? integer[]

local M = {}

--- Runs a command and returns the output.
---@param cmd string | trunks.Command -- Command to run
---@param opts? trunks.RunCmdOpts -- options, such as special error handling
---@return string[], integer -- command output, error code
M.run_cmd = function(cmd, opts)
    opts = opts or {}
    local final_command
    if type(cmd) == "string" then
        -- Remove "git " prefix if given. We shouldn't be passing commands with that
        -- prefix here, but this prevents errors just in case.
        if vim.startswith(cmd, "git ") then
            cmd = cmd:sub(5)
        end
        final_command = require("trunks._core.command").base_command(cmd):build()
    else
        final_command = cmd:build()
    end

    local output, return_code
    if opts.stdin then
        output = vim.fn.systemlist(final_command, opts.stdin)
    else
        output = vim.fn.systemlist(final_command)
    end
    return_code = vim.v.shell_error
    if opts.rerender then
        require("trunks._core.register").rerender_buffers()
    end
    return output, return_code
end

--- Runs a command that doesn't display output.
--- This is used in cases where the UI handles visual updates.
--- This function prints an error message if one is generated by the command.
---@param cmd string | trunks.Command -- Command to run
---@param opts? trunks.RunCmdOpts -- options, such as special error handling
---@return ("success" | "error"), integer
M.run_hidden_cmd = function(cmd, opts)
    opts = opts or {}
    local final_command
    if type(cmd) == "string" then
        -- Remove "git " prefix if given. We shouldn't be passing commands with that
        -- prefix here, but this prevents errors just in case.
        if vim.startswith(cmd, "git ") then
            cmd = cmd:sub(5)
        end
        final_command = require("trunks._core.command").base_command(cmd):build()
    else
        final_command = cmd:build()
    end

    local output
    if opts.stdin then
        output = vim.fn.system(final_command, opts.stdin)
    else
        output = vim.fn.system(final_command)
    end
    local error_code = vim.v.shell_error
    if vim.v.shell_error ~= 0 then
        local should_print_error = not opts.error_codes_to_ignore
            or not vim.tbl_contains(opts.error_codes_to_ignore, error_code)
        if should_print_error then
            vim.notify(output, vim.log.levels.ERROR)
        end
        return "error", error_code
    end
    if opts.rerender then
        require("trunks._core.register").rerender_buffers()
    end
    return "success", error_code
end

return M
